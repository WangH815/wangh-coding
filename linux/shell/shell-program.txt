Shell编程


#参考文档
https://www.runoob.com/linux/linux-shell.html
Linux命令行与shell脚本编程大全.第3版


#简介
Shell是C语言编写,既是命令语言又是程序设计语言;通过Shell提供的界面访问操作系统内核

##常见Shell
Bourne Shell(/usr/bin/sh或/bin/sh)
Bourne Again Shell(/bin/bash)      #适用范围最广,绝大多数Linux发行版默认Shell
C Shell(/usr/bin/csh)
K Shell(/usr/bin/ksh)
Shell for Root(/sbin/sh)
zsh
dsh

cat /etc/shells   #查看系统可使用的Shell不同版本
echo $SHELL       #查看当前使用的shell
chsh -s /bin/zsh  #设置用户默认Shell或者修改 /etc/passwd 文件中对应Shell


#Shell脚本
#!/bin/bash       #脚本第一行,指明运行脚本的Shell

##脚本运行方式
1 . ./xx.sh       #一般用于生效用户配置而不需要重新登录shell,xx.sh有读权限即可
2 source ./xx.sh  #同上。常见用于执行 profile 配置,脚本本身在当前进程中执行
3 sh ./xx.sh      #读权限即可,脚本本身会在子进程中执行
4 ./xx.sh         #需要执行权限,脚本本身会在子进程中执行

##脚本退出状态
一般使用 exit 状态码 指定
echo $?   #打印上一个命令或脚本的退出状态码
状态码    说明
  0       #命令成功结束
  1       #一般性未知错误
  2       #不适合的shell命令
  126     #命令不可执行
  127     #没找到命令
  128     #无效的退出参数
  128+x   #与Linux信号x相关的严重错误
  130     #通过Ctrl+C终止的命令
  255     #正常范围之外的退出状态码;大于255则取余

##注释
#                   #单行注释,例外:#!
:<<EOF              #多行注释,EOF可由单引号或感叹号等替代;结束EOF单独占一行,前后不能有字符
注释内容
注释内容
注释内容
EOF


#变量

##变量类型
1)局部变量
   在脚本或命令中定义,仅在当前shell中有效,其他shell启动的程序不能访问局部变量。
   一般是在函数中定义,如:local var
2)环境变量
所有的程序都能访问环境变量,有些程序需要环境变量来保证其正常运行。
必要的时候shell脚本也可以定义环境变量。
3)shell变量
由shell程序设置的特殊变量。shell变量中有一部分是环境变量,有一部分是局部变量,
这些变量保证了shell的正常运行

###环境变量的设置
1)设置永久环境变量:修改 /etc/profile /etc/bashrc
2)设置用户环境变量:修改 ~/.bash_profile ~/.bash_bashrc
3)临时环境变量: export var="value"
4)显示环境变量: env/set
5)临时取消环境变量: unset var

##命名规则
1.字母、数字和下划线构成
2.不以数字开头
3.系统关键字不能作为变量名
4.字母大小写敏感
5.变量类型默认是字符型
6.一般连续字符、数字、路径等可以不加任何引号,但建议使用双引号
7.其他情况建议使用双引号或单引号
8.反引号一般配合命令使用。如 var=`ls` 等价于 var=$(ls)

##变量声赋值
var=""                #变量置空
unset var             #同上
var=123               #等号两边不能有空格,默认var[0]=123 (数组)
var="ad"              #字符串赋值,也可用单引号(更严格),它可以防止任何变量扩展。
var='ad'              #双引号可防止通配符扩展但允许变量扩展
var1=1;var2=2;var3=3  #同时赋值,分号隔开就可以
var=`cmd`             #命令执行结果赋值给变量
var=$(cmd)            #同上

##变量使用
env                          #查看所有环境变量
set                          #查看所有变量
echo $var                    #打印输出变量值
echo ${var}                  #同上,另一种方式。能识别变量边界,例如$a/$ab/${a}b
readonly var                 #设置变量只读
echo ${#var}                 #输出字符串字符数
echo `expr index "$var" io`  #查找i或o第一次出现的位置(非数组下标)
echo ${var-default}          #var未声明时输出default(可为其他字符串),否则输出var的值。
echo ${var=default}          #同上并赋值
echo ${var:-default}         #var为空或未声明时输出default,否则输出var的值。
echo ${var:=default}         #同上并赋值
echo ${var+default}          #var没有声明则为空,否则为default
echo ${var:+default}         #var的值为非空则为default,否则为空
echo ${var?default}          #var已声明则输出var的值,否则输出default
echo ${var:?default}         #var的值为非空则输出var的值,否则输出default

##变量截取替换(位置从1开始)
var="abcdef"
${var:pos}                   #截取从数组下标为pos(不含pos,下同)之后的子串
${var:pos:len}               #截取pos之后长度为len的子串
${var/Pattern/Replacement}   #使用Replacement来替换var中第一次匹配Pattern的字符串
${var#Pattern/Replacement}   #全部替换
${var/#Pattern/Replacement}  #从var开头匹配,匹配到则替换
${var/%Pattern/Replacement}  #从var结尾匹配,匹配到则替换
${!varpre*}                  #匹配所有已声明变量名以varpre开头的所有变量名,以空格隔开
${!varpre@}                  #同上;单字符串

##变量拼接
${a}${b}
${a}"str"${b}
${a}'str'${b}

##数组变量                       #仅支持一维数组,不限定长度
array_name=(arr1 arr2 arr3 ...)  #赋值,下同
array_name=(
arr1
arr2
...
)
array_name[0]=value0   #单独赋值
array_name[1]=value1   #单独赋值
...                    #单独赋值
array_name[n]=valuen   #单独赋值,数组下标可以不连续
${array_name[n]}       #打印输出某个数组元素
${#array_name[@]}      #打印输出数组元素长度,未定义的不统计
${#array_name[*]}      #同上
${array_name[@]}       #打印输出数组所有元素(未定义的不打印),以多个字符串的形式,元素之间空格分隔
${array_name[*]}       #以一个字符串的形式,其余同上


#基本运算符

##运算符类型
1)算数运算符     #主要用于计算或赋值;其他运算符主要用于条件判断
2)关系运算符
3)布尔运算符     #连接表达式
4)字符串运算符
5)文件测试运算符
注:整数运算主要通过[]、awk(编程语言)、expr和(())实现,[]和expr(也可用于字符串处理)最常用;浮点运算使用bc

#算数运算               #只能用于整数运算
expr                    #evaluate expressions(表达式计算)
a=10,b=20
加法  expr $a + $b      #+左右无空格的会解析为"10+20",其余同理;a,b为数字型字符串也可以;var=$(expr $a + $b)/`expr $a + $b`
      [$a + $b]         #同上;乘法不需要加转义;$[$a+$b]也可以;a,b为数字型字符串部分bash版本支持;var=$[$a+$b]
      [2*(100-3)]       #可使用括号;*等特殊字符无需转义
      ((a+b))/(($a+$b)) #C语言风格计算;推荐使用前者,*等特殊字符无需转义;var=$((a+b))
减法  expr $a - $b
乘法  expr $a \* $b     #*需要转义
除法  expr $b / $a
取余  expr $b % $a
还可以使用如下方法
exp="$var1 + $var2 \* $var3"
expr $exp

#浮点运算可使用 bc 命令
var=`echo "scale=4; 3.44 / 5" | bc`   #scala变量指定小数位数
var=$(echo "scale=4; 3.44 / 5" | bc)  #同上;形式:echo "options; expression" | bc
##复杂运算
var=$(bc << EOF
options
statements
expressions
EOF
)
##例如
var5=$(bc << EOF
scale = 4
a1 = ($var1 * $var2)
b1 = ($var3 * $var4)
a1 + b1
EOF
)

关系运算(数字)
相等     [ $a == $b ]     #等价于 -eq ;注意空格,无空格会解析成字符串拼接;[ $a = $b ]也可以
不相等   [ $a != $b ]     #
相等     [ $a -eq $b ]    #equal简写
不相等   [ $a -ne $b ]    #not equal
大于     [ $a -gt $b ]    #greater than
小于     [ $a -lt $b ]    #less than
大于等于 [ $a -ge $b ]    #greater than or equal
小于等于 [ $a -le $b ]    #less than or equal

布尔运算
[ ! expression ]                #非
[ expression1 -a expression2 ]  #与
[ expression1 -o expression2 ]  #或

逻辑运算
[[ expression1 && expression2 ]]  #and
[[ expression1 || expression2 ]]  #or

字符串运算
[ $a = $b ]    #相等;[ $a == $b ]也可以
[ $a != $b ]   #不相等     
[ -z $a ]      #长度为0    
[ -n "$a" ]    #长度不为0;常用与命令行参数测试,例如:if [ -n $1 ] 来判断是否传递第一个参数
[ $a ]         #不为空     

文件测试运算
[ -b $file ]  #设备文件
[ -c $file ]  #字符设备文件
[ -d $file ]  #目录
[ -f $file ]  #普通文件
[ -g $file ]  #设置了 SGID 位
[ -k $file ]  #设置了粘着位(Sticky Bit)
[ -p $file ]  #管道文件
[ -u $file ]  #设置了 SUID 位
[ -r $file ]  #可读
[ -w $file ]  #可写
[ -x $file ]  #可执行
[ -s $file ]  #不为空(文件大小大于0)
[ -e $file ]  #存在

标准输入输出
read var            #输入        
echo $var/${var}    #输出,输出后自动换行
echo -e             #开启转义
echo `cmd`          #输出命令结果
printf  format-string  [arguments...]  #格式化输出,不自动换行
printf "%-10s %-8s\n" 姓名 性别        #格式化字符串与C语言相同,移植性比echo好

printf转义序列
\a       #警告字符,通常为ASCII的BEL字符
\b       #后退
\c       #抑制(不显示)输出结果中任何结尾的换行字符
         #(只在%b格式指示符控制下的参数字符串中有效),
         #而且,任何留在参数里的字符、任何接下来的参数
         #以及任何留在格式字符串中的字符,都被忽略
\f       #换页(formfeed)
\n       #换行
\r       #回车(Carriage return)
\t       #水平制表符
\v       #垂直制表符
\\       #一个字面上的反斜杠字符
\ddd     #表示1到3位数八进制值的字符。仅在格式字符串中有效
\0ddd    #表示1到3位的八进制值字符

test命令    #等价于 []
用于检查某个条件是否成立,它可以进行数值、字符串和文件三个方面的测试。
1)数值测试
-eq       # =
-ne       # !=
-gt       # >
-ge       # >=
-lt       # <
-le       # <=
格式:if test $var1 -eq $var2    #变量中含有数字之外的字符会报错;var=123/'123'/"123"是合法的
2)字符串测试
=/==      #等于则为真
!=        #不相等则为真
-z        #长度为零
-n        #长度不为零
格式:同1),[]中为字符串或字符串表达式
3)文件测试
-e $file    #文件存在;exist
-r $file    #存在且可读;read
-w $file    #存在且可写;write
-x $file    #存在且可执行;execute
-s $file    #存在且至少有一个字符
-d $file    #存在且为目录;directory
-f $file    #存在且为普通文件;file
-c $file    #存在且为字符型特殊文件;char
-b $file    #存在且为块特殊文件;block
格式:if test -e ./bash  #判断./bash文件是否存在;等价于 if [ -e ./bash ]
##重要
上述命令推荐使用 "$var" 形式,而不是 $var ;若文件(夹)名称中含有空格或.等时使用 $var 会出错


#结构化命令

##if 语句
1)if
#1.conditions可以条件表达式或shell命令(返回值为0表示真)等可以正确执行的指令;其他流程语句条件也是一样
#2.多数条件都是中括号,例如: if [ -f $file ];中括号内左右必须有空格
#3.上一条可使用 if test -f $file 替换
#4.多条件可使用&&(与)和||(或)连接
#5.数学表达式条件可使用双括号,例如: if (( $var ** 2 > 90 ))/if (($var**2>90 ))
#  大于号无需转;变量引用$也可以不加;还支持c语言中的自增自减/逻辑(与或非)/位运算等操作
#6.双括号还可以用于赋值,且等号左右y有无空格都可以;(( val2 = $val1 ** 2 ))
#7.双中括号还支持字符串的匹配,例如: if [[ $var == *as* ]]
if conditions
then
    cmds 
fi
###常用示例
if [ $var1 -eq $var2 ]  #判断变量(数值)是否相等;多条件参考布尔和逻辑运算
if test $var1 -eq $var2 #同上
if [ $var1 -eq $var2 ]  #判断变量(数值)是否相等
if [ -f $file ]         #判断是否为文件
if test -f $file        #同上
if ls                   #执行shell命令(输出结果);命令返回码作为条件判断依据
if (ls)                 #同上
if [ ls ]               #同上;不会输出ls的结果
if cd $var              #跳转目录作为条件
if cd $var;pwd          #跳转目录后执行打印绝对路径作为条件
if (cd $var;pwd)        #操作在子shell中执行
if ./xx.sh              #执行自定义脚本再执行操作
if var=`date`           #赋值语句也是可以的
if var=$(date)          #同上

2)单行格式
if conditions;then cmds;fi                #cmds为多命令使用分号隔开;其他类似
if (conditions) then (cmds) fi            #cmds为多命令使用分号隔开;括号内命令(或条件)在子shell中执行;其他类似
if conditions;then cmds;else cmds;fi
if (conditions) then (cmds) else (cmds) fi
if conditions;then cmds;elif cmds;else cmds;fi

3)if else
if conditions
then
    cmds
else
    cmds
fi

4)if elif else
if condition1
then
    cmds
elif condition2 
then 
    cmds
else
    cmds
fi

##case
case $var in
pattern1 | pattern2) cmds1;;  #无需break
pattern3) cmds2;;
*) default cmds;;
esac

###示例
echo -n "输入 1 到 5 之间的数字: "
read aNum
case $aNum in
    1|2|3|4|5) echo "你输入的数字为 $aNum!"    #模式之间可用|分割
    ;;
    *) echo "你输入的数字不是 1 到 5 之间的!"  # deflaut处理
        continue
        echo "游戏结束"
    ;;
esac


#循环语句
##for循环
for var in list
do
    cmds
done
#list形式
#1.字符串(数字也算),例如:for var in 1 2 3;"1 2 3"被认为单字符串;分隔符(多个算一个)可以是空格/制表符/换行符
#2.普通变量,例如:var="a b c";for var in $var
#3.数组,例如:$var=(a b c);for var in ${var[*]}
#4.shell命令结果,例如: for var in `ls`;`cmd`或$(cmd)的命令形式都可以
#5.文件(夹)通配符,例如: for var in ./*;表示匹配当前路径所有可见文件(夹),相对路径类似
##常用示例
var="a b c";for var in $var
var=(a b c);for var in $var
for var in 1 2 3
for var in '1' '2' '3'   #同上
for var in '1 2 3'       #单双引号会被认为是一个值
for var in `cmds`        #命令结果按照空格/制表符/换行符分隔;多命令以分号隔开
for var in $(cmds)       #同上
for var in `seq 10`      #1-10数组
for var in `seq -1 5`    #指定首尾值
for var in `seq 1 2 10`  #指定首尾及step;实际为1到10的奇数
for var in `seq 10 -2 2` #指定首尾及step;递减
for var in `ls`          #匹配当前文件夹文件(非隐藏)
for var in /home/*       #*匹配/home目录下文件(非隐藏);不会递归匹配
for var in /home/[0-9]*  #带有通配形式的匹配

##分隔符注释,bash shell默认使用IFS(环境变量)表示分隔符(空格/制表符/换行符)
需要修改
IFS_OLD=$IFS
IFS=$'\n'  #修改为换行符;IFS=:表示修改为冒号;多分隔符可使用 IFS=$'\n':;"
<在代码中使用新的IFS值>
IFS=$IFS_OLD

###C语言风格的for循环
for (( variable assignment ; condition ; iteration process ))  #do ... done循环体遵循bash shell语法
例如:
for (( a = 1; a < 10; a++ ))            #单变量形式
for (( a=1, b=10; a <= 10; a++, b-- ))  #多变量形式
for (( ; ; ))                           #可实现无限循环

##while循环          #先判断后执行循环体
while conditions
do
    cmds
done

while conditions;do cmds;done      #单行写的形式
while :;do cmds;done               #无限循环形式
while [];[];[];do cmds;done        #多测试条件形式;某个测试条件不满足则退出循环
while [] && [] && [];do cmds;done  #同上
while [] || [] || [];do cmds;done  #或条件
while cmds;do sleep 10;done        #可实现是定时间执行cmd;标准为cmd成功执行(返回码为0);cmd成功执行后开始计时
while sleep 1;do date;sleep 1;done #每2s输出一次时间

##util循环           #先执行循环体再判断,其余与while相同
until conditions
do
    cmds
done

##循环控制
break      #退出循环;多层循环只会退出内层循环;break n 可退出指定层数循环,n为1时表示当前内层循环
continue   #与C语言中continue一致


#处理用户输入

##命令行参数
###参数读取
./xx.sh arg1 arg2 arg3 ...  #脚本有执行权限,arg开头的为参数
$0        #执行脚本名称,可在脚本中调用
$1/$2/$3  #参数,可在脚本中调用,当n>=10时,需要使用${n}来调用
$#        #传递到脚本的参数个数
$*        #以一个字符串显示所有向脚本传递的参数。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
$$        #脚本运行的当前进程ID号
$!        #后台运行的最后一个进程的ID号
$@        #与$*相同,但是使用时加引号,并在引号中返回每个参数。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
$-        #显示Shell使用的当前选项,与set命令功能相同
$?        #显示最后命令的退出状态;0表示没有错误,其他任何值表明有错误

###移动变量
./xx.sh 1 2 3 4

#!/bin/bash
echo "The original parameters: $*"        #输出 1 2 3 4
shift 2                                   #移除前两个参数;不跟数字移动一位;移除数据无法恢复
echo "Here's the new first parameter: $1" #输出 3

###模拟命令选项和参数的获取     #大部分选项是有对应含义的,可以参考相关文档;
./xx.sh -a -b -c -d -- 1 2

#!/bin/bash
while [ -n "$1" ]   #循环读取每一个选项
do
    case "$1" in
        -a) echo "Found the -a option" ;;
        -b) echo "Found the -b option" ;;
        -c) echo "Found the -c option" ;;
#		-d) param="$2"                     #以下注释的三行为选项后带有参数的处理
#           echo "Found the -b option, with parameter value $param"
#           shift ;;
        --) shift                          #一般认为--为选项结束标志;移除--并跳出循环
		    break ;;
        *) echo "$1 is not an option"  ;;  #其他选项处理
    esac
    shift                                  #移除第一个选项;类似于出队列
done

count=1
for param in $@                            #获取--后参数列表
do
    echo "Parameter #$count: $param"       #打印每个参数
    count=$[ $count + 1 ]                  #参数计数
done

输出 
Found the -a option
Found the -b option
Found the -c option
-d is not an option
Parameter #1: 1
Parameter #2: 2
Parameter #3: 3

##选项参数解析
###getopt
getopt ab:cd -a -b test1 -cd test2 test3     #:表示-b选项需要一个参数;实际打印  -a -b test1 -c -d -- test2 test3
getopt ab:cd -a -b test1 -cde test2 test3    #会先输出getopt: invalid option -- e,然后输出正确的解析结果
getopt -q ab:cd -a -b test1 -cde test2 test3 #-q会屏蔽错误选项e
set -- $(getopt -q ab:cd "$@")               #用于格式化选项及参数;./xx.sh -a -b test1 -cd test2 test3会按照上述去解析选项参数

###getopts    #比getopt更高级
getopts optstring var      #optstring为选项表达式
while getopts :ab:c opt    #表达式第一个:表示去除错误信息;选项如需参数则增加:即可
do
    case "$opt" in      
        a) echo "Found the -a option" ;;
        b) echo "Found the -b option, with value $OPTARG";;  #OPTARG变量用于获取参数后选项
        c) echo "Found the -c option" ;;
        *) echo "Unknown option: $opt";;
    esac
done

##用户输入获取
read            #获取用户输入赋值给 REPLY
read var        #获取用户输入赋值给变量 var
read -s passwd  #用于输入密码不显示在前台,变量中可以使用

###命令超时
if read -t 5 -p "Please enter your name: " name  #设定超时(-t)和提醒(-p)
then
    echo "Hello $name"
else
	echo "Sorry, too slow..."                    #超时后处理
fi

###选择命令
read -n1 -p "Do you want to continue [Y/N]? " answer  #-n1表示接受一个字符后赋值给变量而无需回车
case $answer in
    Y | y) echo "fine, continue on…" ;;
    N | n) echo "OK, goodbye"
	       exit;;
	*) echo "Input Error..."
       exit;;
esac

###文件中读取
cat test | while read line  #从标准输出中读取;逐行读取


#重定向
##注:需要注意的是文件描述符,以下三个是shell保留的;每个进程最多同时有9个文件描述符 
 0  #标准输入(STDIN)
 1  #标准输出(STDOUT)
 2  #标准错误输出(STDERR)

#命令重定向
cmd > file              #将输出重定向到 file
cmd 1> file             #同上
cmd >> file             #将输出以追加的方式重定向到 file
cmd 1>> file            #同上
cmd 2> file             #标准错误输出
cmd 2>> file            #标准错误追加输出
cmd < file              #将输入重定向到 file
cmd 0< file             #同上
cmd < infile > outfile  #infile作为命令参数输入,结果输出到outfile
cmd > file 2>&1         #合并标准输出和错误输出到file;一般错误信息先输出
cmd &> file             #同上
cmd > /dev/null         #屏蔽标准输出(不含错误);/dev/null
cmd > /dev/null 2>&1    #屏蔽所有输出
cmd 1> file1 2> file2   #按文件标识符输出到不同文件      
n> file                 #将文件描述符为 n 的文件重定向到 file
n>> file                #将文件描述符为 n 的文件以追加的方式重定向到 file
n>&m                    #将输出文件 m 和 n 合并
n<&m                    #将输入文件 m 和 n 合并
cmd << delimiter        #分隔符可以使EOF/!等任意合法字符;结束分隔符顶格写,后面不能有任何字符(包含空格等)
context
delimiter

##脚本中重定向
echo "error context" >&2  #临时重定向,;./xx.sh运行时按照标准输出;./xx.sh 2>file会按照错误输出到file中(脚本中指定了exec除外)
exec 1>file               #永久重定向;脚本中使用(一般是开头)会将所有标准输出到file中,而不是控制台
exec 2>file               #错误输出重定向;与上类似
exec 0<file               #输入重定向;与上类似
exec 1>>file              #追加形式
exec 1>&-                 #关闭脚本中文件描述符

##自定义重定向
echo "my context" >&3  #自定义重定向,与>&2逻辑类似;自定义文件描述符可使用3-8
exec 3>file            #文件描述符为3的输出到file中
exec 3>>file           #文件描述符为3的输出到file中
exec 3>&-              #关闭脚本中文件描述符

##重定向示例
./xx.sh < insert.csv
#!/bin/bash
# read file and create INSERT statements for MySQL

outfile='members.sql'   #设定输出文件
IFSOLD=$IFS             #备份分隔符
IFS=','                 #设定逗号为分隔符
while read lname fname address city state zip    #读取每一行数据,设置不同变量
do
  cat >> $outfile << EOF
  INSERT INTO members (lname,fname,address,city,state,zip) VALUES
  ('$lname', '$fname', '$address', '$city', '$state', '$zip');
EOF
done < $1   
IFS=$IFSOLD  #还原默认分隔符


#控制脚本

##信号生成与捕获
Ctrl + c    #中断进程
Ctrl + z    #暂停进程;会给暂停的每个进程一个作业号 n
bg n        #将作业号为 n 的进程转入后台程序
trap        #脚本中使用trap相关命令可捕获信号并处理

##后台运行
cmd &            #后台运行命令;终端退出后即停止执行(会创建守护进程的除外)
./xx.sh &        #后台运行脚本;终端退出后即停止执行(会创建守护进程的除外)
nohup ./xx.sh &  #后台运行且独立于终端;日志会输出到 nohup.out
jobs -l          #查看后台运行的作业(命令或脚本),含PID
kill PID         #停止进程
kill -9 PID      #强制停止进程
nice/renice      #调整进程运行优先级 

##执行计划
at       #用于设置执行计划;会分配作业号
atq      #查看等待运行的执行计划
atrm  n  #删除作业号为n的计划
crontab  #周期执行计划;具体使用参见Linux.txt


#函数

##格式
[ function ] funname [()]
{
    cmds
}

##返回值
1.默认返回最后一条命令的返回码
2.使用return n;n取值范围为0-255,超过取余
3.使用输出语句,例如:echo/print等




Shell引用其他文件
sourse /path/file    #可引用其他文件中变量及函数
. /path/file         #同上