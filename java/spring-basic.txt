Spring基础


参考
https://www.runoob.com/w3cnote/basic-knowledge-summary-of-spring.html
https://zhuanlan.zhihu.com/p/72241378      //10分钟详解Spring全家桶“7大知识点”


Spring简介
此框架由Rod Johnson开发,2004年发布第一版
优点:
1.低侵入式设计,代码的污染极低
2.Spring的IoC容器降低了业务对象替换的复杂性,提高了组件之间的解耦                           //简单,低耦合
3.Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理,从而提供了更好的复用 //高复用
4.Spring的ORM(Object Relational Mapping)和DAO(Data Access Object)提供了与第三方持久层框架的良好整合,
  并简化了底层的数据库访问
5.Spring的高度开放性,并不强制应用完全依赖于Spring,开发者可自由选用Spring框架的部分或全部


JavaBean是特殊的Java类,遵守JavaBean API规范:
1.有无参的构造函数    // 方便框架构建bean
2.成员属性私有化
3.封装的属性如果需要被外所操作，必须编写public类型的setter、getter方法

核心:封装/重用/可读

核心机制
管理Bean

程序主要是通过Spring容器来访问容器中的Bean
ApplicationContext是Spring容器最常用的接口,该接口有如下两个实现类:
ClassPathXmlApplicationContext   //从类加载路径下搜索配置文件来创建Spring容器
FileSystemXmlApplicationContext  //从文件系统的相对路径或绝对路径下去搜索配置文件来创建Spring容器

Example:
public class BeanTest{
    public static void main(String args[]) throws Exception{
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        Person p = ctx.getBean("person", Person.class);
        p.say();
    }
}


Eclipse使用Spring
在Eclipse等IDE工具中,在项目发布时用户需要把Spring的Jar包都放入/WEB-INF/lib目录下


依赖注入(DI)/控制反转(IoC)       //对同一件事情的不同描述
Spring框架的核心功能有两个:
1.Spring容器作为超级大工厂,负责创建、管理所有的Java对象,这些Java对象被称为Bean
2.Spring容器使用"依赖注入"的来管理Bean之间的依赖关系。不仅可为Bean注入普通的属性值,还可注入其他Bean的引用
  依赖注入是一种优秀的解耦方式,其可以让Bean以配置文件组织在一起,而不是以硬编码的方式耦合在一起

理解依赖注入/控制反转
当某个Java对象(调用者)需要调用另一个Java对象(被依赖对象)的方法时,在传统模式下通常有两种做法:
1.原始做法: 调用者主动创建被依赖对象,然后再调用被依赖对象的方法
2.简单工厂模式: 调用者通过先被依赖对象的工厂去获取被依赖对象,再调用被依赖对象的方法
原始做法会导致调用者与被依赖对象实现类的硬编码耦合,不利于项目升级的维护
通过Spring框架,调用者无需主动获取被依赖对象,调用者只要被动接受Spring容器为调用者的成员变量赋值即可,
使用Spring后,调用者获取被依赖对象的方式由原来的主动获取,变成了被动接受——所以Rod Johnson称之为控制反转
Spring容器负责将被依赖对象赋值给调用者的成员变量——相当于为调用者注入它依赖的实例,因此Martine Fowler称之为依赖注入

依赖注入的方式
1.设值注入
IoC容器通过成员变量的setter方法来注入被依赖对象。这种注入方式简单、直观,因而在Spring的依赖注入里大量使用
2.构造注入
利用构造器来设置依赖关系的方式,被称为构造注入。主要通过反射实现

两种注入方式的对比
设值注入有如下优点:
   与传统的JavaBean的写法更相似,更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然
对于复杂的依赖关系,如采用构造注入会导致构造器过于臃肿,难以阅读
Spring在创建Bean实例时,需要同时实例化其依赖的全部实例,因而导致性能下降,而使用设值注入,则能避免这些问题
尤其在某些成员变量可选的情况下,多参数的构造器更加笨重

构造注入优势如下:
    可以在构造器中决定依赖关系的注入顺序,优先依赖的优先注入。对于依赖关系无需变化的Bean,构造注入更有用处
因为没有setter方法,所有的依赖关系全部在构造器内设定,无须担心后续的代码对依赖关系产生破坏。依赖关系只能在
构造器中设定,则只有组件的创建者才能改变组件的依赖关系,对组件的调用者而言,组件内部的依赖关系完全透明,更
符合高内聚的原则

注:建议采用设值注入为主,构造注入为辅的注入策略。对于依赖关系无须变化的注入,尽量采用构造注入;
   而其他依赖关系的注入,则考虑采用设值注入


Spring容器中的Bean
对于开发者来说,开发者使用Spring框架主要是做两件事:
1.开发Bean
2.配置Bean
对于Spring框架来说,它要做的就是根据配置文件来创建Bean实例,并调用Bean实例的方法完成"依赖注入"——这就是所谓IoC的本质

容器中Bean的作用域
当通过Spring容器创建一个Bean实例时,不仅可以完成Bean实例的实例化,还可以为Bean指定特定的作用域
Spring支持如下五种作用域:
1.singleton: 单例模式,在整个Spring IoC容器中,作用域的Bean将只生成一个实例
2.prototype: 每次通过容器的getBean()方法获取prototype作用域的Bean时,都将产生一个新的Bean实例
3.request  : 对于一次HTTP请求,作用域的Bean将只生成一个实例,在同一次HTTP请求内,得到的是同一个Bean实例
4.session  :作用域为 HTTP 会话。只在web-aware Spring ApplicationContext的上下文中有效
5.global session: 每个全局的HTTP Session对应一个Bean实例。在典型的情况下,仅在使用portlet context的时候有效,同样只在Web应用中有效
注:如果不指定Bean的作用域,Spring默认使用singleton作用域。prototype作用域的Bean的创建、销毁代价比较大
而singleton作用域的Bean实例一旦创建成果,就可以重复使用。因此,应该尽量避免将Bean设置成prototype作用域


使用自动装配注入合作者Bean

Spring能自动装配Bean之间的依赖关系,无须使用ref显式指定依赖Bean,通过配置文件实现依赖注入
自动装配可通过<beans/>元素的default-autowire属性对配置文件中所有的Bean起作用；或通过对<bean/>元素的autowire属性单个Bean的作用

autowire和default-autowire可以接受如下值:
1.no: 默认配置,不使用自动装配。依赖需通过ref元素定义。复杂项目中建议不要修改,显式配置更清晰
2.byName: 根据setter方法名进行自动装配。Spring容器查找容器中全部Bean,匹配同名的Bean来完成注入。无匹配则不注入
3.byType: 根据setter方法的形参类型来自动装配。Spring容器查找容器中的全部Bean,匹配形参类型的Bean来完成注入；如出现多个匹配的Bean,则抛出异常；无匹配则不注入
4.constructor: 与byType类似,区别是用于自动匹配构造器的参数。如果容器不能恰好找到一个与构造器参数类型匹配的Bean,则会抛出一个异常
5.autodetect: Spring容器根据Bean内部结构,自动使用constructor或byType策略。如果找到一个默认的构造函数,那么就会应用byType策略
注:当一个Bean既使用自动装配依赖,又使用ref显式指定依赖时,则显式指定的依赖覆盖自动装配依赖；对于大型的应用,不鼓励使用自动装配

配置Example
<!--通过设置可以将Bean排除在自动装配之外-->
<bean id="Bean-name" autowire-candidate="false"/>

<!--除此之外,还可以在beans元素中指定,支持模式字符串,如下所有以abc结尾的Bean都被排除在自动装配之外-->
<beans default-autowire-candidates="*abc"/>

创建Bean的3种方式
1.使用构造器创建Bean实例
  最常见的方式,如不采用构造注入,Spring底层会调用Bean类的无参数构造器来创建实例,因此要求该Bean类提供无参数的构造器
  并对Bean实例的所有属性执行默认初始化,基本类型为0或false,引用类型为null
2.使用静态工厂方法创建Bean
  使用此方法时,class属性必须指定,但属性并不是指定Bean实例的实现类,而是静态工厂类,Spring通过该属性知道由哪个工厂类来创建Bean实例
  此外,还需要使用factory-method属性来指定静态工厂方法,Spring将调用静态工厂方法返回一个Bean实例,一旦获得了指定Bean实例,
  Spring后面的处理步骤与采用普通方法创建Bean实例完全一样。如果静态工厂方法需要参数,则使用<constructor-arg.../>元素指定静态工厂方法的参数
3.调用实例工厂方法创建Bean
  与静态工厂方法只有一个不同:
  调用静态工厂方法只需使用工厂类即可,而调用实例工厂方法则需要工厂实例。使用实例工厂方法时,配置Bean实例的<bean.../>元素无须class属性,
  配置实例工厂方法使用factory-bean指定工厂实例。采用实例工厂方法创建Bean的<bean.../>元素时需要指定如下两个属性:
  1)factory-bean: 该属性的值为工厂Bean的id
  2)factory-method: 该属性指定实例工厂的工厂方法
  若调用实例工厂方法时需要传入参数,则使用<constructor-arg.../>元素确定参数值


协调作用域不同步的Bean

当singleton作用域的Bean依赖于prototype作用域的Bean时,会产生不同步的现象,原因是因为当Spring容器初始化时,
容器会预初始化容器中所有的singleton Bean,由于singleton Bean依赖于prototype Bean,因此Spring在初始化singleton Bean之前,
会先创建prototype Bean——然后才创建singleton Bean,接下里将prototype Bean注入singleton Bean
解决不同步的方法有两种:
1.放弃依赖注入: singleton作用域的Bean每次需要prototype作用域的Bean时,主动向容器请求新的Bean实例
2.利用方法注入: 方法注入通常使用lookup方法注入,可以让Spring容器重写容器中Bean的抽象或具体方法,返回查找容器中其他Bean的结果,
被查找的Bean通常是一个non-singleton Bean。Spring通过使用JDK动态代理或cglib库修改客户端的二进制码,从而实现上述要求
建议采用第二种方法,使用方法注入。为了使用lookup方法注入,大致需要如下两步:
1)将调用者Bean的实现类定义为抽象类,并定义一个抽象方法来获取被依赖的Bean
2)在<bean.../>元素中添加<lookup-method.../>子元素让Spring为调用者Bean的实现类实现指定的抽象方法
注:Spring会采用运行时动态增强的方式来实现<lookup-method.../>元素所指定的抽象方法,如果目标抽象类实现过接口,
Spring会采用JDK动态代理来实现该抽象类,并为之实现抽象方法；如果目标抽象类没有实现过接口,Spring会采用cglib实现该抽象类,
并为之实现抽象方法。Spring4.0的spring-core-xxx.jar包中已经集成了cglib类库


两种后处理器

Spring提供了两种常用的后处理器:

1.Bean后处理器
    这种后处理器会对容器中Bean进行后处理,对Bean进行额外加强
    一种特殊的Bean,不对外提供服务,可无须id属性,它主要负责对容器中的其他Bean执行后处理,例如为容器中的目标Bean生成代理等,
这种Bean称为Bean后处理器
它在Bean实例创建成功之后,对Bean实例进行增强处理。Bean后处理器必须实现BeanPostProcessor接口,同时必须实现该接口的两个方法
方法1:Object postProcessBeforeInitialization(Object bean, String name) throws BeansException
      该方法的第一个参数是系统即将进行后处理的Bean实例,第二个参数是该Bean的配置id
方法2:Object postProcessAfterinitialization(Object bean, String name) throws BeansException
      该方法的第一个参数是系统即将进行后处理的Bean实例,第二个参数是该Bean的配置id
2.容器后处理器
    这种后处理器会对IoC容器进行后处理,用于增强容器功能
    容器后处理器则负责处理容器本身。容器后处理器必须实现BeanFactoryPostProcessor接口,并实现该接口的一个方法
postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)实现该方法的方法体就是对Spring容器进行的处理,
这种处理可以对Spring容器进行自定义扩展,当然也可以对Spring容器不进行任何处理
类似于BeanPostProcessor,ApplicationContext可自动检测到容器中的容器后处理器,并且自动注册容器后处理器
但若使用BeanFactory作为Spring容器,则必须手动调用该容器后处理器来处理BeanFactory容器


Spring的"零配置"支持

搜索Bean类
Spring提供如下几个Annotation来标注Spring Bean:
1.@Component   //组件;标注一个普通的Spring Bean类
2.@Controller  //控制器;标注一个控制器组件类
3.@Service     //服务;标注一个业务逻辑组件类
4.@Repository  //仓库;标注一个DAO组件类

在Spring配置文件中做如下配置,指定自动扫描的包:
<context:component-scan base-package="edu.shu.spring.domain"/>

使用@Resource配置依赖
@Resource位于javax.annotation包下,是来自JavaEE规范的一个Annotation,Spring直接借鉴了该Annotation,
通过使用该Annotation为目标Bean指定协作者Bean。使用@Resource与<property.../>元素的ref属性有相同的效果
@Resource不仅可以修饰setter方法,也可以直接修饰实例变量,如果使用@Resource修饰实例变量将会更加简单,
此时Spring将会直接使用JavaEE规范的Field注入,此时连setter方法都可以不要

使用@PostConstruct和@PreDestroy定制生命周期行为
@PostConstruct和@PreDestroy同样位于javax.annotation包下,也是来自JavaEE规范的两个Annotation,Spring直接借鉴了它们,
用于定制Spring容器中Bean的生命周期行为。它们都用于修饰方法,无须任何属性。其中前者修饰的方法时Bean的初始化方法；
而后者修饰的方法时Bean销毁之前的方法

Spring4.0增强的自动装配和精确装配
Spring提供了@Autowired注解来指定自动装配,可以修饰setter方法、普通方法、实例变量和构造器等。当使用@Autowired标注
setter方法时,默认采用byType自动装配策略。在这种策略下,符合自动装配类型的候选Bean实例常常有多个,这个时候就可能
引起异常,为了实现精确的自动装配,Spring提供了@Qualifier注解,通过使用@Qualifier,允许根据Bean的id来执行自动装配


AOP(Aspect Orient Programming)    //面向切面编程

作为面向对象编程的一种补充,已经成为一种比较成熟的编程方式。将程序运行过程分解成各个切面
AOP专门用于处理系统中分布于各个模块(不同方法)中的交叉关注点的问题,在JavaEE应用中,常常通过AOP来处理一些
具有横切性质的系统级服务,如事务管理、安全检查、缓存、对象池管理等,AOP已经成为一种非常常用的解决方案

使用AspectJ实现AOP
AspectJ是一个基于Java语言的AOP框架,提供了强大的AOP功能,其他很多AOP框架都借鉴或采纳其中的一些思想
其主要包括两个部分:
1.定义了AOP编程中的语法规范,通过这套语法规范,可以方便地用AOP来解决Java语言中存在的交叉关注点的问题
2.工具部分,包括编译、调试工具等

AOP实现可分为两类:
1.静态AOP实现: AOP框架在编译阶段对程序进行修改,即实现对目标类的增强,生成静态的AOP代理类,以AspectJ为代表
2.动态AOP实现: AOP框架在运行阶段动态生成AOP代理,以实现对目标对象的增强,以Spring AOP为代表
注:一般来说,静态AOP实现具有较好的性能,但需要使用特殊的编译器。动态AOP实现是纯Java实现,但是通常性能略差

AOP的基本概念
关于面向切面编程的一些术语:
切面(Aspect):      切面用于组织多个Advice,Advice放在切面中定义
连接点(Joinpoint): 程序执行过程中明确的点,如方法的调用,或者异常的抛出。在Spring AOP中,连接点总是方法的调用
增强处理(Advice):  AOP框架在特定的切入点执行的增强处理。处理有"around"、"before"和"after"等类型
切入点(Pointcut):  可以插入增强处理的连接点。当某连接点满足指定要求时,该连接点将被添加增强处理,也就变成了切入点

Spring的AOP支持
Spring中的AOP代理由Spring的IoC容器负责生成、管理,其依赖关系也由IoC容器负责管理
为了在应用中使用@AspectJ支持,Spring需要添加三个库:aspectjweaver.jar/aspectjrt.jar/aopalliance.jar

并在Spring配置文件中做如下配置:
<!--启动@AspectJ支持-->
<aop:aspectj-autoproxy/>

<!--指定自动搜索Bean组件、自动搜索切面类-->
<context:component-scan base-package="edu.shu.sprint.service">
    <context:include-filter type="annotation" expression="org.aspectj.lang.annotation.Aspect"/>
</context:component-scan>







